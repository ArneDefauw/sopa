file = "..."
sdata_path = f"{file}.zarr"
config = "..."

rule all:
    input:
        "..."

checkpoint write_sdata:
    input:
        file,
        config,
    output:
        sdata_path,
        poly_paths_file,
    shell:
        f"""
        python -m sopa.io.qptiff -p {file} -s {sdata_path} -c {config}
        ... # write file with paths
        """

def get_input_patches(wilcards):
    with open(checkpoints.write_sdata.get(**wilcards).output[1], 'r') as f:
        n_tiles = int(json.load(f)["window_grid"]["num_tiles"])
    return ...

rule patch_segmentation:
    input:
        run.out.spec,
    output:
        f"{run.out.tiles_dir}/{{index}}.parquet",
    resources:
        mem_mb=3_000
    conda:
        "vpt"
    shell:
        f"""
        vpt --verbose run-segmentation-on-tile \
            --input-segmentation-parameters {run.out.spec} \
            --tile-index {{wildcards.index}}
        """

rule aggregate_patches:
    input:
        run.out.spec,
        get_input_patches,
    output:
        run.out.polygons,
    resources:
        mem_mb=32_000
    conda:
        "vpt"
    shell:
        f"""
        vpt --verbose compile-tile-segmentation \
            --input-segmentation-parameters {run.out.spec}
        """