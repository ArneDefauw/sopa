from utils import WorkflowPaths, Args

assert "sdata_path" in config.keys(), "Argument --sdata_path is required"

paths = WorkflowPaths(config)
args = Args(paths, config)

rule all:
    input:
        paths.polygons,
        paths.annotations,
        paths.explorer_experiment,

rule to_spatialdata: # TODO: update
    input:
        paths.raw,
    output:
        paths.sdata_zgroup,
    conda:
        "spatial"
    params:
        reader_name = config["reader"]["name"],
    shell:
        """
        sopa read {params.reader_name} {paths.sdata_path} {paths.raw}
        """

checkpoint patchify:
    input:
        paths.sdata_zgroup,
    output:
        n_patches = paths.smk_n_patches,
        patches = directory(paths.patches),
    params:
        args_patchify = str(args["patchify"]),
        args_baysor = args.dump_baysor_patchify() if args.baysor else "",
    conda:
        "spatial"
    shell:
        """
        sopa patchify {paths.sdata_path} {params.args_patchify} {params.args_baysor}
        """

if args.cellpose:
    rule patch_segmentation_cellpose:
        input:
            paths.smk_n_patches,
            paths.patches,
        output:
            "{paths.cellpose_dir}/{index}.zarr.zip",
        conda:
            "spatial"
        params:
            args_cellpose = str(args["segmentation"]["cellpose"]),
        shell:
            """
            sopa segmentation cellpose {paths.sdata_path} --patch-dir {paths.cellpose_dir} --patch-index {wildcards.index} {params.args_cellpose}
            """

if args.baysor:
    rule patch_segmentation_baysor:
        input:
            n_patches = paths.smk_n_patches,
            baysor_patch = f"{paths.baysor_dir}/{{index}}",
        output:
            f"{paths.baysor_dir}/{{index}}/segmentation_polygons.json"
        params:
            args_baysor_cell_key = args.baysor_cell_key,
        shell:
            """
            cd {input.baysor_patch}
            {config[executables][baysor]} run --save-polygons GeoJSON -c config.toml transcripts.csv {params.args_baysor_cell_key}
            """

def get_input_resolve(name):
    import json
    def _(wilcards):
        with open(checkpoints.patchify.get(**wilcards).output.n_patches, 'r') as f:
            return paths.cells_paths(json.load(f)[name], name)
    return _

if args.cellpose:
    rule resolve_cellpose:
        input:
            get_input_resolve("cellpose"),
        output:
            directory(paths.polygons),
        conda:
            "spatial"
        params:
            args_expand_radius = args.expand_radius,
        shell:
            """
            sopa resolve cellpose {paths.sdata_path} --patch-dir {paths.cellpose_dir} --expand-radius {params.args_expand_radius}
            """

if args.baysor:
    rule resolve_baysor:
        input:
            get_input_resolve("baysor"),
        output:
            directory(paths.polygons),
            touch(paths.smk_table)
        conda:
            "spatial"
        shell:
            """
            N=$(echo {input[0]} | tr ' ' '\\n' | wc -l);
            sopa resolve baysor {paths.sdata_path} --baysor-dir {paths.baysor_dir} --gene-column {args.gene_column} --n $N
            """

rule aggregate:
    input:
        paths.polygons,
    output:
        touch(paths.smk_aggregation),
    conda:
        "spatial"
    params:
        args_aggregate = str(args["aggregate"]),
    shell:
        """
        sopa aggregate {paths.sdata_path} {params.args_aggregate}
        """

rule annotate:
    input:
        paths.smk_table if not args.aggregate else paths.smk_aggregation,
    output:
        directory(paths.annotations),
    conda:
        "spatial"
    params:
        args_fluorescence = str(args["annotation"]["fluorescence"])
    shell:
        """
        sopa annotate fluorescence {paths.sdata_path} {params.args_fluorescence}
        """

rule explorer:
    input:
        paths.polygons,
        paths.smk_aggregation if args.aggregate else paths.smk_table,
        paths.annotations if args.annotate else [],
    output:
        paths.explorer_experiment,
    conda:
        "spatial"
    params:
        args_explorer = str(args["explorer"]),
    shell:
        """
        sopa explorer {paths.sdata_path} {paths.explorer_directory} {params.args_explorer}
        """