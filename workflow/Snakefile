from utils import WorkflowPaths, Args

assert "sdata_path" in config.keys(), "Argument --sdata_path is required"

paths = WorkflowPaths(config)
args = Args(paths, config)

rule all:
    input:
        paths.annotations,
        paths.explorer_experiment,

rule to_spatialdata: # TODO: update
    input:
        paths.raw,
    output:
        paths.sdata_zgroup,
    conda:
        "spatial"
    params:
        reader_name = config["reader"]["name"],
    shell:
        """
        sopa read {params.reader_name} {paths.sdata_path} {paths.raw}
        """

checkpoint patchify_cellpose:
    input:
        paths.sdata_zgroup,
    output:
        n_patches = paths.smk_n_patches_cellpose,
        patches = directory(paths.patches),
    params:
        args_patchify = str(args["patchify"].where(contains="pixel")),
    conda:
        "spatial"
    shell:
        """
        sopa patchify cellpose {paths.sdata_path} {params.args_patchify}
        """

checkpoint patchify_baysor:
    input:
        paths.sdata_zgroup,
        paths.cellpose_boundaries if args.cellpose else [],
    output:
        n_patches = paths.smk_n_patches_baysor,
        baysor_temp_dir = directory(paths.baysor_temp_dir),
    params:
        args_patchify = str(args["patchify"].where(contains="micron")),
        args_baysor = args.dump_baysor_patchify() if args.baysor else "",
        arg_prior = "--use-prior" if args.cellpose else ""
    conda:
        "spatial"
    shell:
        """
        sopa patchify baysor {paths.sdata_path} {params.args_patchify} {params.args_baysor} {params.arg_prior}
        """

rule patch_segmentation_cellpose:
    input:
        paths.smk_n_patches_cellpose,
        paths.patches,
    output:
        f"{paths.cellpose_temp_dir}/{{index}}.zarr.zip",
    conda:
        "spatial"
    params:
        args_cellpose = str(args["segmentation"]["cellpose"]),
    shell:
        """
        sopa segmentation cellpose {paths.sdata_path} --patch-dir {paths.cellpose_temp_dir} --patch-index {wildcards.index} {params.args_cellpose}
        """

rule patch_segmentation_baysor:
    input:
        n_patches = paths.smk_n_patches_baysor,
        baysor_patch = f"{paths.baysor_temp_dir}/{{index}}",
    output:
        f"{paths.baysor_temp_dir}/{{index}}/segmentation_polygons.json"
    params:
        args_baysor_cell_key = args.baysor_cell_key,
    resources:
        mem_mb=64_000,
    shell:
        """
        cd {input.baysor_patch}
        if command -v module &> /dev/null; then
            module purge
        fi
        
        {config[executables][baysor]} run --save-polygons GeoJSON -c config.toml transcripts.csv {params.args_baysor_cell_key}
        """

def get_input_resolve(name):
    def _(wilcards):
        with getattr(checkpoints, f"patchify_{name}").get(**wilcards).output.n_patches.open() as f:
            return paths.cells_paths(int(f.read()), name)
    return _

rule resolve_cellpose:
    input:
        get_input_resolve("cellpose"),
    output:
        directory(paths.cellpose_boundaries),
    conda:
        "spatial"
    params:
        args_expand_radius = args.expand_radius,
    shell:
        """
        sopa resolve cellpose {paths.sdata_path} --patch-dir {paths.cellpose_temp_dir} --expand-radius {params.args_expand_radius}
        """

rule resolve_baysor:
    input:
        get_input_resolve("baysor"),
    output:
        directory(paths.baysor_boundaries),
        touch(paths.smk_table)
    conda:
        "spatial"
    shell:
        """
        N=$(echo {input[0]} | tr ' ' '\\n' | wc -l);
        sopa resolve baysor {paths.sdata_path} --baysor-temp-dir {paths.baysor_temp_dir} --gene-column {args.gene_column} --n $N
        """

rule aggregate:
    input:
        paths.baysor_boundaries if args.baysor else paths.cellpose_boundaries,
    output:
        touch(paths.smk_aggregation),
    conda:
        "spatial"
    params:
        args_aggregate = str(args["aggregate"]),
    shell:
        """
        sopa aggregate {paths.sdata_path} {params.args_aggregate}
        """

rule annotate:
    input:
        paths.smk_table if not args.aggregate else paths.smk_aggregation,
    output:
        directory(paths.annotations),
    conda:
        "spatial"
    params:
        args_fluorescence = str(args["annotation"]["fluorescence"])
    shell:
        """
        sopa annotate fluorescence {paths.sdata_path} {params.args_fluorescence}
        """

rule explorer:
    input:
        paths.baysor_boundaries if args.baysor else paths.cellpose_boundaries,
        paths.smk_aggregation if args.aggregate else paths.smk_table,
        paths.annotations if args.annotate else [],
    output:
        paths.explorer_experiment,
    conda:
        "spatial"
    resources:
        mem_mb=128_000,
    params:
        args_explorer = str(args["explorer"]),
    shell:
        """
        sopa explorer {paths.sdata_path} {paths.explorer_directory} {params.args_explorer}
        """