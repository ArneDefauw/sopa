from utils import WorkflowPaths, Args

assert "sdata_path" in config.keys(), "Argument --sdata_path is required"

paths = WorkflowPaths(config)
args = Args(paths, config)

rule all:
    input:
        paths.polygons,
        paths.annotations,
        paths.explorer_experiment,

rule to_spatialdata:
    input:
        paths.raw,
    output:
        paths.sdata_zgroup,
    conda:
        "spatial"
    params:
        reader_name = config["reader"]["name"],
    shell:
        """
        sopa read {params.reader_name} {paths.sdata_path} {paths.raw}
        """

checkpoint patchify:
    input:
        paths.sdata_zgroup,
    output:
        n_patches = paths.smk_n_patches,
        patches = directory(paths.patches),
    params:
        patchify_args = args["patchify"],
        baysor_args = args.dump_baysor_patchify() if args.baysor else "",
    conda:
        "spatial"
    shell:
        """
        sopa patchify {paths.sdata_path} {params.patchify_args} {params.baysor_args}
        """

if args.cellpose:
    rule patch_segmentation_cellpose:
        input:
            paths.smk_n_patches,
            paths.patches,
        output:
            "{paths.cellpose_dir}/{index}.zarr.zip",
        conda:
            "spatial"
        params:
            args_cellpose = args["segmentation"]["cellpose"],
        shell:
            """
            sopa segmentation cellpose {paths.sdata_path} --patch-dir {paths.cellpose_dir} --patch-index {wildcards.index} {params.args_cellpose}
            """

if args.baysor:
    rule patch_segmentation_baysor:
        input:
            paths.smk_n_patches,
            baysor_patch = f"{paths.baysor_dir}/{{index}}",
        output:
            f"{paths.baysor_dir}/{{index}}/segmentation_polygons.json"
        shell:
            f"""
            cd {{input.baysor_patch}}
            {config['executables']['baysor']} run --save-polygons GeoJSON -c config.toml transcripts.csv {args.baysor_cell_id}
            """

def get_input_resolve(name):
    import json
    def _(wilcards):
        with open(checkpoints.patchify.get(**wilcards).output.n_patches, 'r') as f:
            return paths.cells_paths(json.load(f)[name], name)
    return _

if args.cellpose:
    rule resolve_cellpose:
        input:
            get_input_resolve("cellpose"),
        output:
            directory(paths.polygons),
        conda:
            "spatial"
        shell:
            """
            sopa resolve cellpose {paths.sdata_path} --patch-dir {paths.cellpose_dir} --expand-radius {args.expand_radius}
            """

if args.baysor:
    rule resolve_baysor:
        input:
            get_input_resolve("baysor"),
        output:
            directory(paths.polygons),
            touch(paths.smk_table)
        conda:
            "spatial"
        shell:
            """
            sopa resolve baysor {paths.sdata_path} --baysor-dir {paths.baysor_dir} --gene-column {args.gene_column}
            """

rule aggregate:
    input:
        paths.polygons,
    output:
        touch(paths.smk_aggregation),
    conda:
        "spatial"
    params:
        args_aggregate = args["aggregate"],
    shell:
        """
        sopa aggregate {paths.sdata_path} {params.args_aggregate}
        """

rule annotate:
    input:
        paths.smk_table if not args.aggregate else paths.smk_aggregation,
    output:
        directory(paths.annotations),
    conda:
        "spatial"
    params:
        args_fluorescence = args["annotation"]["fluorescence"]
    shell:
        """
        sopa annotate fluorescence {paths.sdata_path} {params.args_fluorescence}
        """

rule explorer:
    input:
        paths.polygons,
        paths.smk_aggregation if args.aggregate else paths.smk_table,
        paths.annotations if args.annotate else [],
    output:
        paths.explorer_experiment,
    conda:
        "spatial"
    params:
        args_explorer = args["explorer"]
    shell:
        """
        sopa explorer {paths.sdata_path} {paths.explorer_directory} {params.args_explorer}
        """