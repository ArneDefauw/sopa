from utils import WorkflowPaths, dump_args

assert "sdata_path" in config.keys(), "Argument --sdata_path is required"

paths = WorkflowPaths(config)

rule all:
    input:
        paths.polygons,
        paths.annotations,
        paths.explorer_experiment,

rule to_spatialdata:
    input:
        paths.raw,
    output:
        paths.sdata_zgroup,
    conda:
        "spatial"
    shell:
        f"""
        sopa read {config["reader"]["name"]} {paths.sdata_path} {paths.raw}
        """

checkpoint patchify:
    input:
        paths.sdata_zgroup,
    output:
        paths.n_patches_path,
        directory(paths.patches),
    conda:
        "spatial"
    shell:
        f"""
        sopa patchify {paths.sdata_path} {dump_args(config["patchify"])} {paths.dump_baysor_patchify() if paths.run_baysor else ""}
        """

def baysor_cell_id():
    if "cell_id" not in config["segmentation"]["baysor"]:
        return ""
    return f":{config['segmentation']['baysor']['cell_id']}"

if paths.run_cellpose:
    rule patch_segmentation_cellpose:
        input:
            paths.n_patches_path,
            paths.patches,
        output:
            f"{paths.cellpose_dir}/{{index}}.zarr.zip",
        conda:
            "spatial"
        shell:
            f"""
            sopa segmentation cellpose {paths.sdata_path} --patch-dir {paths.cellpose_dir} --patch-index {{wildcards.index}} {dump_args(config["segmentation"]["cellpose"])}
            """
else:
    rule patch_segmentation_baysor:
        input:
            paths.n_patches_path,
            baysor_patch = f"{paths.baysor_dir}/{{index}}",
        output:
            f"{paths.baysor_dir}/{{index}}/segmentation_polygons.json"
        shell:
            f"""
            baysor run --save-polygons GeoJSON -c {{input.baysor_patch}}/config.toml {{input.baysor_patch}}/transcripts.csv {baysor_cell_id()}
            """

def get_input_resolve(name):
    import json

    def _(wilcards):
        with open(checkpoints.patchify.get(**wilcards).output[0], 'r') as f:
            return paths.cells_paths(json.load(f)[name], name)
    return _

if paths.run_cellpose:
    rule resolve_cellpose:
        input:
            get_input_resolve("cellpose"),
        output:
            directory(paths.polygons),
        conda:
            "spatial"
        shell:
            f"""
            sopa resolve cellpose {paths.sdata_path} --patch-dir {paths.cellpose_dir} --expand-radius {config["segmentation"]["cellpose"]["expand_radius"]}
            """
else:
    rule resolve_baysor:
        input:
            get_input_resolve("baysor"),
        output:
            directory(paths.polygons),
            touch(paths.table)
        conda:
            "spatial"
        shell:
            f"""
            sopa resolve baysor {paths.sdata_path} --baysor-dir {paths.baysor_dir} --gene-column {config["segmentation"]["baysor"]["config"]["data"]["gene"]}
            """

rule aggregate:
    input:
        paths.polygons,
    output:
        touch(paths.table),
    conda:
        "spatial"
    shell:
        f"""
        sopa aggregate {paths.sdata_path} {dump_args(config["aggregate"])}
        """

rule annotate:
    input:
        paths.table,
    output:
        directory(paths.annotations),
    conda:
        "spatial"
    shell:
        f"""
        sopa annotate fluorescence {paths.sdata_path} {dump_args(config["annotation"]["fluorescence"])}
        """

rule explorer:
    input:
        paths.polygons,
        paths.annotations,
    output:
        paths.explorer_experiment,
    conda:
        "spatial"
    shell:
        f"""
        sopa explorer {paths.sdata_path} {paths.explorer_directory} {dump_args(config["explorer"])}
        """